#!/usr/bin/env bash
set -euo pipefail

VERSION="0.2.7"

CONFIG_PATH="${BAKKER_CONFIG:-}"
BAKKER_API_URL=""
BAKKER_IMAGE=""
BAKKER_DOCKER_NETWORK=""
REQUEST_TIMEOUT=""
DEFAULT_OUTPUT=""
DEFAULT_CONFIRM_IMPORT=""
DEFAULT_PROFILE=""

OVERRIDE_API_URL=""
OVERRIDE_IMAGE=""
OVERRIDE_DOCKER_NETWORK=""
OVERRIDE_TIMEOUT=""
OVERRIDE_OUTPUT=""
OVERRIDE_PROFILE=""

PROFILE_NAMES=""

usage() {
  cat <<'USAGE'
Usage:
  bakker [global options] <command> [options]
  bakker help [command]

Global options:
  --config <path>        Path to config.toml (default: ./bakker.config.toml, then ~/.config/bakker/bakker.config.toml)
  --api-url <url>        Override Bakker API URL
  --image <ref>          Override tooling image (default: sebaswouters/bakker:latest)
  --docker-network <n>   Optional docker network for image runs
  --timeout <seconds>    Override API timeout
  --output <table|json>  Override output format
  --profile <name>       Default destination profile for import
  --help                 Show this help

Commands:
  backup list [--db <name>] [--latest] [--json]                List backups from Bakker API (with IDs)
  import [--profile <name>] [--yes] <id|filename>              Import backup into destination DB
  profiles list                                                 List configured destination profiles
  profiles show <name>                                          Show one destination profile
  doctor                                                        Run local and Bakker health checks
  version                                                       Print CLI version

Password env convention:
  For profile "<name>", set "<NAME>_DB_PASS" (uppercased, non-alnum -> _).
  Example: profile "local-dev" -> LOCAL_DEV_DB_PASS

Examples:
  bakker --help
  bakker help import
  bakker backup --help
  bakker import --help
USAGE
}

usage_backups() {
  cat <<'USAGE'
Usage:
  bakker backup list [--db <name>] [--latest] [--json]

Options:
  --db <name>    Filter backups to a Bakker database config name
  --latest       Show only latest backup per database (or for --db)
  --json         Print raw API JSON instead of table output
  --help, -h     Show this help
USAGE
}

usage_import() {
  cat <<'USAGE'
Usage:
  bakker import [--profile <name>] [--yes] <id|filename>

Options:
  --profile <name>  Destination profile from config.toml (or [defaults].profile)
  --yes             Skip import confirmation prompt
  --help, -h        Show this help

Arguments:
  <id|filename>     Backup ID from 'bakker backup list', or local .sql.gz file

Notes:
  - For ID-based imports, Bakker API token comes from BAKKER_AUTH_TOKEN or interactive prompt.
  - Destination DB password lookup order: <PROFILE>_DB_PASS env var, then profile password in config, then interactive prompt.
  - Supported import format: .sql.gz.
USAGE
}

usage_profiles() {
  cat <<'USAGE'
Usage:
  bakker profiles list
  bakker profiles show <name>

Options:
  --help, -h    Show this help
USAGE
}

usage_doctor() {
  cat <<'USAGE'
Usage:
  bakker doctor

Runs local and Bakker connectivity checks.

Options:
  --help, -h    Show this help
USAGE
}

command_help() {
  local topic="${1:-}"
  case "$topic" in
    ""|-h|--help) usage ;;
    backup|backups) usage_backups ;;
    import) usage_import ;;
    profiles) usage_profiles ;;
    doctor) usage_doctor ;;
    version)
      cat <<'USAGE'
Usage:
  bakker version
USAGE
      ;;
    *)
      echo "Error: unknown help topic '$topic'" >&2
      usage >&2
      exit 2
      ;;
  esac
}

trim() {
  local s="$1"
  s="${s#"${s%%[![:space:]]*}"}"
  s="${s%"${s##*[![:space:]]}"}"
  printf '%s' "$s"
}

strip_inline_comment() {
  local s="$1"
  local out=""
  local i ch
  local in_single="false"
  local in_double="false"

  for ((i = 0; i < ${#s}; i++)); do
    ch="${s:i:1}"
    if [[ "$ch" == "'" && "$in_double" == "false" ]]; then
      if [[ "$in_single" == "true" ]]; then
        in_single="false"
      else
        in_single="true"
      fi
      out+="$ch"
      continue
    fi
    if [[ "$ch" == '"' && "$in_single" == "false" ]]; then
      if [[ "$in_double" == "true" ]]; then
        in_double="false"
      else
        in_double="true"
      fi
      out+="$ch"
      continue
    fi
    if [[ "$ch" == "#" && "$in_single" == "false" && "$in_double" == "false" ]]; then
      break
    fi
    out+="$ch"
  done

  printf '%s' "$out"
}

strip_quotes() {
  local v
  v="$(trim "$1")"
  if [[ "$v" =~ ^\"(.*)\"$ ]]; then
    printf '%s' "${BASH_REMATCH[1]}"
    return
  fi
  if [[ "$v" =~ ^\'(.*)\'$ ]]; then
    printf '%s' "${BASH_REMATCH[1]}"
    return
  fi
  printf '%s' "$v"
}

profile_key() {
  local name="$1"
  local key="$2"
  printf 'PROFILE__%s__%s' "$name" "$key"
}

set_profile_value() {
  local name="$1"
  local key="$2"
  local value="$3"
  local var
  var="$(profile_key "$name" "$key")"
  printf -v "$var" '%s' "$value"
}

get_profile_value() {
  local name="$1"
  local key="$2"
  local var
  var="$(profile_key "$name" "$key")"
  printf '%s' "${!var-}"
}

add_profile_name() {
  local name="$1"
  if [[ -z "$PROFILE_NAMES" ]]; then
    PROFILE_NAMES="$name"
    return
  fi
  local existing
  for existing in $PROFILE_NAMES; do
    if [[ "$existing" == "$name" ]]; then
      return
    fi
  done
  PROFILE_NAMES="$PROFILE_NAMES $name"
}

ensure_config_exists() {
  local cwd_config="./bakker.config.toml"
  local home_config="$HOME/.config/bakker/bakker.config.toml"

  if [[ -n "$CONFIG_PATH" ]]; then
    if [[ -f "$CONFIG_PATH" ]]; then
      return 0
    fi
    echo "Error: config file not found at $CONFIG_PATH" >&2
    echo "Create it first (see cli/README.md for an example)." >&2
    exit 3
  fi

  if [[ -f "$cwd_config" ]]; then
    CONFIG_PATH="$cwd_config"
    return 0
  fi

  if [[ -f "$home_config" ]]; then
    CONFIG_PATH="$home_config"
    return 0
  fi

  echo "Error: config file not found." >&2
  echo "Checked: $cwd_config" >&2
  echo "Checked: $home_config" >&2
  echo "Create one first (see cli/README.md for an example)." >&2
  exit 3
}

load_config() {
  ensure_config_exists

  local section=""
  local line raw key value profile_name

  while IFS= read -r raw || [[ -n "$raw" ]]; do
    line="$(strip_inline_comment "$raw")"
    line="$(trim "$line")"
    [[ -z "$line" ]] && continue

    if [[ "$line" =~ ^\[(.+)\]$ ]]; then
      section="${BASH_REMATCH[1]}"
      continue
    fi

    if [[ ! "$line" =~ ^([A-Za-z0-9_.-]+)[[:space:]]*=[[:space:]]*(.+)$ ]]; then
      continue
    fi

    key="${BASH_REMATCH[1]}"
    value="$(strip_quotes "${BASH_REMATCH[2]}")"

    case "$section" in
      bakker)
        case "$key" in
          api_url) BAKKER_API_URL="$value" ;;
          image) BAKKER_IMAGE="$value" ;;
          docker_network) BAKKER_DOCKER_NETWORK="$value" ;;
          timeout_seconds) REQUEST_TIMEOUT="$value" ;;
        esac
        ;;
      defaults)
        case "$key" in
          output) DEFAULT_OUTPUT="$value" ;;
          confirm_import) DEFAULT_CONFIRM_IMPORT="$value" ;;
          profile) DEFAULT_PROFILE="$value" ;;
        esac
        ;;
      profiles.*)
        profile_name="${section#profiles.}"
        add_profile_name "$profile_name"
        case "$key" in
          host|port|user|database|password)
            set_profile_value "$profile_name" "$key" "$value"
            ;;
        esac
        ;;
    esac
  done < "$CONFIG_PATH"

  [[ -z "$BAKKER_API_URL" ]] && BAKKER_API_URL="http://localhost:3500"
  [[ -z "$BAKKER_IMAGE" ]] && BAKKER_IMAGE="sebaswouters/bakker:latest"
  [[ -z "$REQUEST_TIMEOUT" ]] && REQUEST_TIMEOUT="30"
  [[ -z "$DEFAULT_OUTPUT" ]] && DEFAULT_OUTPUT="table"
  [[ -z "$DEFAULT_CONFIRM_IMPORT" ]] && DEFAULT_CONFIRM_IMPORT="true"

  if [[ -n "$OVERRIDE_API_URL" ]]; then
    BAKKER_API_URL="$OVERRIDE_API_URL"
  fi
  if [[ -n "$OVERRIDE_IMAGE" ]]; then
    BAKKER_IMAGE="$OVERRIDE_IMAGE"
  fi
  if [[ -n "$OVERRIDE_DOCKER_NETWORK" ]]; then
    BAKKER_DOCKER_NETWORK="$OVERRIDE_DOCKER_NETWORK"
  fi
  if [[ -n "$OVERRIDE_TIMEOUT" ]]; then
    REQUEST_TIMEOUT="$OVERRIDE_TIMEOUT"
  fi
  if [[ -n "$OVERRIDE_OUTPUT" ]]; then
    DEFAULT_OUTPUT="$OVERRIDE_OUTPUT"
  fi
  if [[ -n "$OVERRIDE_PROFILE" ]]; then
    DEFAULT_PROFILE="$OVERRIDE_PROFILE"
  fi

  return 0
}

require_cmd() {
  local cmd="$1"
  command -v "$cmd" >/dev/null 2>&1 || {
    echo "Error: required command not found: $cmd" >&2
    exit 3
  }
}

require_runtime() {
  require_cmd curl
  require_cmd docker
}

get_auth_token() {
  local token
  if [[ -n "${BAKKER_AUTH_TOKEN:-}" ]]; then
    token="$BAKKER_AUTH_TOKEN"
  elif [[ -t 0 ]]; then
    read -r -s -p "Enter Bakker API token: " token
    echo
  else
    echo "Error: BAKKER_AUTH_TOKEN is not set and no interactive TTY is available." >&2
    exit 3
  fi

  token="$(trim "$token")"
  # Remove common terminal paste wrappers/control chars that can break auth headers.
  token="${token//$'\e[200~'/}"
  token="${token//$'\e[201~'/}"
  token="$(printf '%s' "$token" | tr -d '\r\n' | tr -d '[:cntrl:]')"
  token="$(trim "$token")"

  # Strip optional surrounding quotes if pasted as a quoted value.
  if [[ "$token" =~ ^\"(.*)\"$ ]]; then
    token="${BASH_REMATCH[1]}"
  elif [[ "$token" =~ ^\'(.*)\'$ ]]; then
    token="${BASH_REMATCH[1]}"
  fi

  if [[ "$token" == [Bb]earer\ * ]]; then
    token="${token#* }"
  fi

  if [[ -z "$token" ]]; then
    echo "Error: token is required." >&2
    exit 3
  fi

  printf '%s' "$token"
}

normalize_api_url() {
  local url="$1"
  url="$(trim "$url")"
  url="${url%/}"
  if [[ "$url" == */api ]]; then
    url="${url%/api}"
  fi
  printf '%s' "$url"
}

api_request() {
  local method="$1"
  local path="$2"
  local token="$3"
  local tmp_file status

  tmp_file="$(mktemp)"
  local request_url
  request_url="$(normalize_api_url "$BAKKER_API_URL")$path"

  status="$(curl -sS -o "$tmp_file" -w '%{http_code}' --max-time "$REQUEST_TIMEOUT" \
    -H "Authorization: Bearer $token" \
    -X "$method" \
    "$request_url")" || {
      rm -f "$tmp_file"
      echo "Error: request failed: $method $request_url" >&2
      exit 4
    }

  if [[ "$status" -ge 400 ]]; then
    echo "Error: API returned HTTP $status for $method $path" >&2
    echo "Request URL: $request_url" >&2
    if [[ "$status" -eq 400 ]]; then
      echo "Hint: verify [bakker].api_url in config and token format." >&2
      echo "Hint: try exporting BAKKER_AUTH_TOKEN to avoid hidden paste chars in interactive input." >&2
    fi
    cat "$tmp_file" >&2
    rm -f "$tmp_file"
    exit 4
  fi

  cat "$tmp_file"
  rm -f "$tmp_file"
}

json_transform_with_bakker_bun() {
  local js_code="$1"
  docker_run_tool bun -e "$js_code"
}

url_encode_with_bakker_bun() {
  local raw="$1"
  printf '%s' "$raw" | docker_run_tool bun -e 'const fs=require("fs"); const s=fs.readFileSync(0, "utf8"); process.stdout.write(encodeURIComponent(s));'
}

docker_run_tool() {
  local network_args=()
  local env_args=()
  local var_name
  if [[ -n "$BAKKER_DOCKER_NETWORK" ]]; then
    network_args=(--network "$BAKKER_DOCKER_NETWORK")
  fi

  # json transforms run inside a container, so forward lookup/filter vars explicitly.
  for var_name in BACKUP_ID DB_FILTER LATEST_ONLY; do
    if [[ -v "$var_name" ]]; then
      env_args+=(-e "$var_name=${!var_name}")
    fi
  done

  docker run --rm -i "${network_args[@]}" "${env_args[@]}" "$BAKKER_IMAGE" "$@"
}

print_backups_table() {
  local json_data="$1"
  local filter_db="$2"
  local latest_only="$3"

  local js_code
  js_code='const fs=require("fs");
const input=fs.readFileSync(0,"utf8");
const dbFilter=process.env.DB_FILTER||"";
const latest=(process.env.LATEST_ONLY||"false")==="true";
let parsed={};
try { parsed=JSON.parse(input||"{}"); } catch { parsed={}; }
const rows=[];
for (const [db,list] of Object.entries(parsed)) {
  if (!Array.isArray(list)) continue;
  for (const item of list) {
    const parsedId=Number(item?.id);
    rows.push({
      id:Number.isInteger(parsedId) && parsedId>0 ? parsedId : null,
      db,
      date:item?.date||"",
      size:item?.sizeHuman||item?.sizeMB||"",
      name:item?.filename||""
    });
  }
}
rows.sort((a,b)=>{
  if (a.db===b.db) return (b.date||"").localeCompare(a.date||"");
  return a.db.localeCompare(b.db);
});
const outputRows=[];
const latestSeen=new Set();
for (const row of rows) {
  if (dbFilter && row.db!==dbFilter) continue;
  if (latest) {
    if (latestSeen.has(row.db)) continue;
    latestSeen.add(row.db);
  }
  outputRows.push(row);
}
console.log("ID\tNAME\tDATE\tDB\tSIZE");
for (const r of outputRows) {
  const idDisplay=r.id===null ? "-" : String(r.id);
  console.log(`${idDisplay}\t${r.name}\t${r.date}\t${r.db}\t${r.size}`);
}'

  while IFS=$'\t' read -r col1 col2 col3 col4 col5; do
    printf '%-5s %-48s %-19s %-20s %s\n' "$col1" "$col2" "$col3" "$col4" "$col5"
  done < <(
    printf '%s' "$json_data" | DB_FILTER="$filter_db" LATEST_ONLY="$latest_only" json_transform_with_bakker_bun "$js_code"
  )
}

resolve_backup_file_by_id() {
  local json_data="$1"
  local backup_id="$2"
  local js_code

  js_code='const fs=require("fs");
const input=fs.readFileSync(0,"utf8");
const rawId=process.env.BACKUP_ID||"";
const backupId=Number.parseInt(rawId, 10);
if (!Number.isInteger(backupId) || backupId < 1) {
  process.exit(2);
}
let parsed={};
try { parsed=JSON.parse(input||"{}"); } catch { parsed={}; }
const rows=[];
for (const [db,list] of Object.entries(parsed)) {
  if (!Array.isArray(list)) continue;
  for (const item of list) {
    const parsedId=Number(item?.id);
    rows.push({
      id:Number.isInteger(parsedId) && parsedId>0 ? parsedId : null,
      db,
      date:item?.date||"",
      file:item?.filename||""
    });
  }
}
rows.sort((a,b)=>{
  if (a.db===b.db) return (b.date||"").localeCompare(a.date||"");
  return a.db.localeCompare(b.db);
});
const selected=rows.find((row) => row.id===backupId);
if (!selected || !selected.file) process.exit(2);
process.stdout.write(`${selected.file}\t${selected.db}`);'

  printf '%s' "$json_data" | BACKUP_ID="$backup_id" json_transform_with_bakker_bun "$js_code"
}

print_available_server_backup_ids() {
  local json_data="$1"
  local js_code

  js_code='const fs=require("fs");
const input=fs.readFileSync(0,"utf8");
let parsed={};
try { parsed=JSON.parse(input||"{}"); } catch { parsed={}; }
const ids=[];
for (const list of Object.values(parsed)) {
  if (!Array.isArray(list)) continue;
  for (const item of list) {
    const parsedId=Number(item?.id);
    if (Number.isInteger(parsedId) && parsedId>0) ids.push(parsedId);
  }
}
const unique=[...new Set(ids)].sort((a,b)=>a-b);
if (unique.length===0) process.exit(0);
process.stdout.write(unique.join(", "));'

  printf '%s' "$json_data" | json_transform_with_bakker_bun "$js_code"
}

require_profile() {
  local profile="$1"
  local found="false"
  local p
  for p in $PROFILE_NAMES; do
    if [[ "$p" == "$profile" ]]; then
      found="true"
      break
    fi
  done

  if [[ "$found" != "true" ]]; then
    echo "Error: profile '$profile' not found in $CONFIG_PATH" >&2
    exit 3
  fi

  local host port user database
  host="$(get_profile_value "$profile" host)"
  port="$(get_profile_value "$profile" port)"
  user="$(get_profile_value "$profile" user)"
  database="$(get_profile_value "$profile" database)"

  if [[ -z "$host" ]]; then
    echo "Error: profile '$profile' missing host" >&2
    exit 3
  fi
  if [[ -z "$port" ]]; then
    echo "Error: profile '$profile' missing port" >&2
    exit 3
  fi
  if [[ -z "$user" ]]; then
    echo "Error: profile '$profile' missing user" >&2
    exit 3
  fi
  if [[ -z "$database" ]]; then
    echo "Error: profile '$profile' missing database" >&2
    exit 3
  fi

  return 0
}

command_backups_list() {
  local filter_db=""
  local latest_only="false"
  local output_mode="$DEFAULT_OUTPUT"

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --db)
        [[ $# -lt 2 ]] && { echo "Error: --db requires a value" >&2; exit 2; }
        filter_db="$2"
        shift 2
        ;;
      --latest)
        latest_only="true"
        shift
        ;;
      --json)
        output_mode="json"
        shift
        ;;
      --help|-h)
        usage_backups
        return 0
        ;;
      *)
        echo "Error: unknown option for backup list: $1" >&2
        exit 2
        ;;
    esac
  done

  local token json_data
  token="$(get_auth_token)"
  json_data="$(api_request GET "/api/backups" "$token")"

  if [[ "$output_mode" == "json" ]]; then
    printf '%s\n' "$json_data"
    return 0
  fi

  print_backups_table "$json_data" "$filter_db" "$latest_only"
}

confirm_if_needed() {
  local prompt="$1"
  local no_confirm="$2"

  if [[ "$no_confirm" == "true" ]]; then
    return 0
  fi

  if [[ "$DEFAULT_CONFIRM_IMPORT" == "false" ]]; then
    return 0
  fi

  local answer
  read -r -p "$prompt [y/N]: " answer
  case "$answer" in
    y|Y|yes|YES) return 0 ;;
    *)
      echo "Aborted."
      exit 5
      ;;
  esac
}

prompt_db_password() {
  local profile="$1"
  local password
  read -r -s -p "Enter destination DB password for profile '$profile': " password
  echo
  if [[ -z "$password" ]]; then
    echo "Error: destination DB password is required." >&2
    exit 3
  fi
  printf '%s' "$password"
}

profile_password_env_name() {
  local profile="$1"
  local upper sanitized
  upper="$(printf '%s' "$profile" | tr '[:lower:]' '[:upper:]')"
  sanitized="$(printf '%s' "$upper" | tr -c 'A-Z0-9' '_')"
  printf '%s_DB_PASS' "$sanitized"
}

get_profile_db_password() {
  local profile="$1"
  local env_name env_value config_value
  env_name="$(profile_password_env_name "$profile")"
  env_value="${!env_name-}"

  if [[ -n "$env_value" ]]; then
    echo "Using destination DB password from \$$env_name for profile '$profile'." >&2
    printf '%s' "$env_value"
    return 0
  fi

  config_value="$(get_profile_value "$profile" password)"
  if [[ -n "$config_value" ]]; then
    echo "Using destination DB password from config profile '$profile'." >&2
    printf '%s' "$config_value"
    return 0
  fi

  prompt_db_password "$profile"
}

print_connectivity_hint() {
  local host="$1"
  if [[ "$host" == "127.0.0.1" || "$host" == "localhost" || "$host" == "::1" ]]; then
    echo "Hint: destination host '$host' is loopback inside the Docker restore container." >&2
    echo "On Linux, set [bakker].docker_network = \"host\" to reach your host-local DB." >&2
    echo "Alternative: use a host/IP reachable from Docker (or host.docker.internal where supported)." >&2
  fi
}

connectivity_check() {
  local host="$1"
  local port="$2"
  local user="$3"
  local database="$4"
  local password="$5"

  local network_args=()
  if [[ -n "$BAKKER_DOCKER_NETWORK" ]]; then
    network_args=(--network "$BAKKER_DOCKER_NETWORK")
  fi

  docker run --rm "${network_args[@]}" \
    -e DEST_HOST="$host" \
    -e DEST_PORT="$port" \
    -e DEST_USER="$user" \
    -e DEST_DB="$database" \
    -e DEST_PASSWORD="$password" \
    "$BAKKER_IMAGE" \
    sh -lc '
      set -eu
      if ! command -v mysql >/dev/null 2>&1; then
        echo "No SQL client found: mysql." >&2
        exit 1
      fi
      MYSQL_PWD="$DEST_PASSWORD" mysql -h "$DEST_HOST" -P "$DEST_PORT" -u "$DEST_USER" -D "$DEST_DB" -e "SELECT 1;" >/dev/null
    '
}

run_import() {
  local profile="$DEFAULT_PROFILE"
  local import_arg=""
  local force_local_file="false"
  local no_confirm="false"

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --profile)
        [[ $# -lt 2 ]] && { echo "Error: --profile requires a value" >&2; exit 2; }
        profile="$2"
        shift 2
        ;;
      --id)
        echo "Error: --id is no longer supported." >&2
        echo "Use positional syntax: 'bakker import <id>'." >&2
        exit 2
        ;;
      --file)
        [[ $# -lt 2 ]] && { echo "Error: --file requires a value" >&2; exit 2; }
        if [[ -n "$import_arg" ]]; then
          echo "Error: import accepts exactly one target (<id|filename>)." >&2
          echo "Usage: bakker import [--profile <name>] [--yes] <id|filename>" >&2
          exit 2
        fi
        import_arg="$2"
        force_local_file="true"
        shift 2
        ;;
      --from-file)
        [[ $# -lt 2 ]] && { echo "Error: --from-file requires a value" >&2; exit 2; }
        if [[ -n "$import_arg" ]]; then
          echo "Error: import accepts exactly one target (<id|filename>)." >&2
          echo "Usage: bakker import [--profile <name>] [--yes] <id|filename>" >&2
          exit 2
        fi
        import_arg="$2"
        force_local_file="true"
        shift 2
        ;;
      --db|--latest)
        echo "Error: --db/--latest is no longer supported for import." >&2
        echo "Use 'bakker backup list' to find an ID, then run 'bakker import <id>'." >&2
        exit 2
        ;;
      --yes)
        no_confirm="true"
        shift
        ;;
      --help|-h)
        usage_import
        return 0
        ;;
      -*)
        echo "Error: unknown option for import: $1" >&2
        exit 2
        ;;
      *)
        if [[ -n "$import_arg" ]]; then
          echo "Error: import accepts exactly one target (<id|filename>)." >&2
          echo "Usage: bakker import [--profile <name>] [--yes] <id|filename>" >&2
          exit 2
        fi
        import_arg="$1"
        shift
        ;;
    esac
  done

  [[ -z "$profile" ]] && { echo "Error: --profile is required (or set [defaults].profile / global --profile)" >&2; exit 2; }

  if [[ -z "$import_arg" ]]; then
    echo "Error: import requires an <id|filename> argument." >&2
    echo "Example: bakker import 5" >&2
    echo "Example: bakker import ./dump.sql.gz" >&2
    exit 2
  fi

  require_profile "$profile"

  local host port user database
  host="$(get_profile_value "$profile" host)"
  port="$(get_profile_value "$profile" port)"
  user="$(get_profile_value "$profile" user)"
  database="$(get_profile_value "$profile" database)"

  local filename=""
  local selected_db=""
  local import_mode=""
  local local_file_path=""
  local token=""
  if [[ "$force_local_file" != "true" && "$import_arg" =~ ^[0-9]+$ ]]; then
    if [[ "$import_arg" -lt 1 ]]; then
      echo "Error: <id> must be a positive integer from 'bakker backup list'." >&2
      exit 2
    fi
    import_mode="id"
    local backup_id="$import_arg"
    local backups_json resolved
    token="$(get_auth_token)"
    backups_json="$(api_request GET "/api/backups" "$token")"
    if ! resolved="$(resolve_backup_file_by_id "$backups_json" "$backup_id")"; then
      echo "Error: no backup found for ID '$backup_id'." >&2
      echo "Tip: run 'bakker --config $CONFIG_PATH backup list' and choose an ID from the first column." >&2
      local available_ids
      available_ids="$(print_available_server_backup_ids "$backups_json" || true)"
      if [[ -n "$available_ids" ]]; then
        echo "Server IDs currently available: $available_ids" >&2
      else
        echo "The server response did not contain usable backup IDs." >&2
      fi
      exit 4
    fi
    IFS=$'\t' read -r filename selected_db <<<"$resolved"
    if [[ -z "$filename" ]]; then
      echo "Error: backup ID '$backup_id' resolved to an empty filename." >&2
      exit 4
    fi
    echo "Resolved backup ID $backup_id to '$filename' (database '$selected_db')."
  else
    import_mode="local-file"
    local_file_path="$import_arg"
    if [[ ! -f "$local_file_path" ]]; then
      echo "Error: local file not found: $local_file_path" >&2
      exit 4
    fi
    if [[ "$local_file_path" != *.sql.gz ]]; then
      echo "Error: unsupported local backup format: $local_file_path" >&2
      echo "Expected .sql.gz." >&2
      exit 4
    fi
    filename="$(basename "$local_file_path")"
    echo "Using local import file '$local_file_path'."
  fi

  local db_password
  db_password="$(get_profile_db_password "$profile")"

  echo "Checking destination connectivity for profile '$profile'..."
  if ! connectivity_check "$host" "$port" "$user" "$database" "$db_password"; then
    echo "Error: failed to connect to destination DB ($user@$host:$port/$database)." >&2
    print_connectivity_hint "$host"
    exit 5
  fi

  local import_label="$filename"
  if [[ "$import_mode" == "local-file" ]]; then
    import_label="$local_file_path"
  fi
  confirm_if_needed "Import backup '$import_label' into profile '$profile' ($user@$host:$port/$database)?" "$no_confirm"
  echo "Starting import of '$import_label' into '$profile'..."

  local network_args=()
  if [[ -n "$BAKKER_DOCKER_NETWORK" ]]; then
    network_args=(--network "$BAKKER_DOCKER_NETWORK")
  fi

  local load_sql_from_stream_script=""
  read -r -d '' load_sql_from_stream_script <<'SCRIPT' || true
set -eu
if ! command -v mysql >/dev/null 2>&1; then
  echo "ERROR: No SQL client found: mysql." >&2
  exit 1
fi
gunzip | MYSQL_PWD="$DEST_PASSWORD" mysql -h "$DEST_HOST" -P "$DEST_PORT" -u "$DEST_USER" "$DEST_DB"
SCRIPT

  if [[ "$import_mode" == "id" ]]; then
    if [[ "$filename" != *.sql.gz ]]; then
      echo "Error: unsupported server backup format for '$filename'." >&2
      echo "Supported format is .sql.gz." >&2
      exit 4
    fi

    local encoded_filename
    encoded_filename="$(url_encode_with_bakker_bun "$filename")"
    curl -sS --fail-with-body --max-time "$REQUEST_TIMEOUT" \
      -H "Authorization: Bearer $token" \
      "$(normalize_api_url "$BAKKER_API_URL")/api/backups/$encoded_filename" \
      | docker run --rm -i "${network_args[@]}" \
          -e DEST_PASSWORD="$db_password" \
          -e DEST_HOST="$host" \
          -e DEST_PORT="$port" \
          -e DEST_USER="$user" \
          -e DEST_DB="$database" \
          "$BAKKER_IMAGE" \
          sh -lc "$load_sql_from_stream_script"
  else
    cat "$local_file_path" \
      | docker run --rm -i "${network_args[@]}" \
          -e DEST_PASSWORD="$db_password" \
          -e DEST_HOST="$host" \
          -e DEST_PORT="$port" \
          -e DEST_USER="$user" \
          -e DEST_DB="$database" \
          "$BAKKER_IMAGE" \
          sh -lc "$load_sql_from_stream_script"
  fi

  echo "Import completed successfully."
}

profiles_list() {
  local p
  if [[ -z "$PROFILE_NAMES" ]]; then
    echo "No profiles defined in $CONFIG_PATH"
    return 0
  fi

  for p in $PROFILE_NAMES; do
    printf '%s\n' "$p"
  done
}

profiles_show() {
  local profile="${1:-}"
  [[ -z "$profile" ]] && { echo "Error: profile name is required" >&2; exit 2; }

  require_profile "$profile"

  echo "profile = $profile"
  echo "host = $(get_profile_value "$profile" host)"
  echo "port = $(get_profile_value "$profile" port)"
  echo "user = $(get_profile_value "$profile" user)"
  echo "database = $(get_profile_value "$profile" database)"
  if [[ -n "$(get_profile_value "$profile" password)" ]]; then
    echo "password = [set in config]"
  else
    echo "password = [not set in config]"
  fi
}

doctor() {
  echo "Running doctor checks..."

  require_runtime
  echo "- curl: ok"
  echo "- docker: ok"

  if [[ -f "$CONFIG_PATH" ]]; then
    echo "- config: ok ($CONFIG_PATH)"
  else
    echo "- config: missing ($CONFIG_PATH)"
    exit 3
  fi

  if docker image inspect "$BAKKER_IMAGE" >/dev/null 2>&1; then
    echo "- image '$BAKKER_IMAGE': available"
  else
    echo "- image '$BAKKER_IMAGE': not present locally (will be pulled on first run)"
  fi

  if docker run --rm "$BAKKER_IMAGE" true >/dev/null 2>&1; then
    echo "- image run: ok"
  else
    echo "- image run: failed (check image name, network, and registry access)"
    exit 3
  fi

  local token
  if [[ -n "${BAKKER_AUTH_TOKEN:-}" ]]; then
    token="$BAKKER_AUTH_TOKEN"
  else
    echo "- token: not set in env (interactive token will be required for API commands)"
    return 0
  fi

  if api_request GET "/api/auth-required" "$token" >/dev/null; then
    echo "- API auth: ok"
  else
    echo "- API auth: failed"
    exit 4
  fi
}

parse_global_options() {
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --config)
        [[ $# -lt 2 ]] && { echo "Error: --config requires a value" >&2; exit 2; }
        CONFIG_PATH="$2"
        shift 2
        ;;
      --api-url)
        [[ $# -lt 2 ]] && { echo "Error: --api-url requires a value" >&2; exit 2; }
        OVERRIDE_API_URL="$2"
        shift 2
        ;;
      --image)
        [[ $# -lt 2 ]] && { echo "Error: --image requires a value" >&2; exit 2; }
        OVERRIDE_IMAGE="$2"
        shift 2
        ;;
      --docker-network)
        [[ $# -lt 2 ]] && { echo "Error: --docker-network requires a value" >&2; exit 2; }
        OVERRIDE_DOCKER_NETWORK="$2"
        shift 2
        ;;
      --timeout)
        [[ $# -lt 2 ]] && { echo "Error: --timeout requires a value" >&2; exit 2; }
        OVERRIDE_TIMEOUT="$2"
        shift 2
        ;;
      --output)
        [[ $# -lt 2 ]] && { echo "Error: --output requires a value" >&2; exit 2; }
        OVERRIDE_OUTPUT="$2"
        shift 2
        ;;
      --profile)
        [[ $# -lt 2 ]] && { echo "Error: --profile requires a value" >&2; exit 2; }
        OVERRIDE_PROFILE="$2"
        shift 2
        ;;
      --help|-h)
        usage
        exit 0
        ;;
      help)
        shift
        command_help "${1:-}"
        exit 0
        ;;
      version)
        echo "$VERSION"
        exit 0
        ;;
      backup|backups|import|profiles|doctor)
        break
        ;;
      *)
        echo "Error: unknown global option or command: $1" >&2
        usage >&2
        exit 2
        ;;
    esac
  done

  REMAINING_ARGS=("$@")
}

main() {
  require_runtime
  parse_global_options "$@"
  set -- "${REMAINING_ARGS[@]}"

  if [[ $# -lt 1 ]]; then
    usage
    exit 2
  fi

  local cmd="$1"
  shift

  # Help paths should work even when config file is missing.
  case "$cmd" in
    backup|backups)
      if [[ "${1:-}" == "--help" || "${1:-}" == "-h" || "${1:-}" == "help" || -z "${1:-}" ]]; then
        usage_backups
        return 0
      fi
      if [[ "${1:-}" == "list" && ( "${2:-}" == "--help" || "${2:-}" == "-h" ) ]]; then
        usage_backups
        return 0
      fi
      ;;
    import)
      if [[ "${1:-}" == "--help" || "${1:-}" == "-h" || "${1:-}" == "help" ]]; then
        usage_import
        return 0
      fi
      ;;
    profiles)
      if [[ "${1:-}" == "--help" || "${1:-}" == "-h" || "${1:-}" == "help" || -z "${1:-}" ]]; then
        usage_profiles
        return 0
      fi
      ;;
    doctor)
      if [[ "${1:-}" == "--help" || "${1:-}" == "-h" || "${1:-}" == "help" ]]; then
        usage_doctor
        return 0
      fi
      ;;
  esac

  load_config

  case "$cmd" in
    backup|backups)
      local sub="${1:-}"
      if [[ "$sub" != "list" ]]; then
        echo "Error: expected 'backup list'" >&2
        exit 2
      fi
      shift
      command_backups_list "$@"
      ;;
    import)
      run_import "$@"
      ;;
    profiles)
      local sub="${1:-}"
      shift || true
      case "$sub" in
        list) profiles_list ;;
        show) profiles_show "${1:-}" ;;
        *)
          echo "Error: profiles command must be 'list' or 'show <name>'" >&2
          exit 2
          ;;
      esac
      ;;
    doctor)
      doctor
      ;;
    *)
      echo "Error: unknown command: $cmd" >&2
      usage >&2
      exit 2
      ;;
  esac
}

main "$@"
